==== BEGIN: hardened/current/master ====
current branch: hardened/current/master
mergeable branch: freebsd/current/master
==== change branch ====
Switched to branch 'hardened/current/master'
Your branch is up to date with 'origin/hardened/current/master'.
==== show current branch ====
  freebsd/11-stable/master
  freebsd/11.2-releng/master
  freebsd/12-stable/master
  freebsd/12.1-releng/master
  freebsd/current/master
  hardened/11-stable/master
  hardened/11.2-releng/master
  hardened/12-stable/master
  hardened/12.1-releng/master
* hardened/current/master
==== check for stale changes ====
==== update to latest origin ====
Already up to date.
==== merge branches ====
==== merge freebsd/current/master branch ====
Auto-merging bin/pwait/pwait.c
CONFLICT (content): Merge conflict in bin/pwait/pwait.c
Automatic merge failed; fix conflicts and then commit the result.
==== merge failed at freebsd/current/master branch ====
diff --cc bin/pwait/pwait.c
index 85ecc7b7b2b0,4c21984de3f9..000000000000
--- a/bin/pwait/pwait.c
+++ b/bin/pwait/pwait.c
@@@ -64,19 -63,23 +63,24 @@@ in
  main(int argc, char *argv[])
  {
  	struct itimerval itv;
- 	int kq;
  	struct kevent *e;
- 	int tflag, verbose;
- 	int opt, nleft, n, i, duplicate, status;
+ 	int oflag, tflag, verbose;
+ 	int i, kq, n, nleft, opt, status;
  	long pid;
- 	char *s, *end;
+ 	char *end, *s;
  	double timeout;
 +	pid_t me;
  
- 	tflag = verbose = 0;
+ 	oflag = 0;
+ 	tflag = 0;
+ 	verbose = 0;
  	memset(&itv, 0, sizeof(itv));
- 	while ((opt = getopt(argc, argv, "t:v")) != -1) {
+ 
+ 	while ((opt = getopt(argc, argv, "ot:v")) != -1) {
  		switch (opt) {
+ 		case 'o':
+ 			oflag = 1;
+ 			break;
  		case 't':
  			tflag = 1;
  			errno = 0;
@@@ -116,18 -120,19 +121,21 @@@
  	argc -= optind;
  	argv += optind;
  
- 	if (argc == 0)
+ 	if (argc == 0) {
  		usage();
+ 	}
  
 +	me = getpid();
 +
  	kq = kqueue();
- 	if (kq == -1)
- 		err(1, "kqueue");
+ 	if (kq == -1) {
+ 		err(EX_OSERR, "kqueue");
+ 	}
  
  	e = malloc((argc + tflag) * sizeof(struct kevent));
- 	if (e == NULL)
- 		err(1, "malloc");
+ 	if (e == NULL) {
+ 		err(EX_OSERR, "malloc");
+ 	}
  	nleft = 0;
  	for (n = 0; n < argc; n++) {
  		s = argv[n];
@@@ -139,21 -146,23 +149,41 @@@
  			warnx("%s: bad process id", s);
  			continue;
  		}
++<<<<<<< HEAD
 +		if (pid == me) {
 +			warnx("%s: ignoring own process id", s);
 +			continue;
 +		}
 +		duplicate = 0;
 +		for (i = 0; i < nleft; i++)
 +			if (e[i].ident == (uintptr_t)pid)
 +				duplicate = 1;
 +		if (!duplicate) {
 +			EV_SET(e + nleft, pid, EVFILT_PROC, EV_ADD, NOTE_EXIT,
 +			    0, NULL);
 +			if (kevent(kq, e + nleft, 1, NULL, 0, NULL) == -1)
 +				warn("%ld", pid);
 +			else
 +				nleft++;
++=======
+ 		for (i = 0; i < nleft; i++) {
+ 			if (e[i].ident == (uintptr_t)pid) {
+ 				break;
+ 			}
+ 		}
+ 		if (i < nleft) {
+ 			/* Duplicate. */
+ 			continue;
+ 		}
+ 		EV_SET(e + nleft, pid, EVFILT_PROC, EV_ADD, NOTE_EXIT, 0, NULL);
+ 		if (kevent(kq, e + nleft, 1, NULL, 0, NULL) == -1) {
+ 			warn("%ld", pid);
+ 			if (oflag) {
+ 				exit(EX_OK);
+ 			}
+ 		} else {
+ 			nleft++;
++>>>>>>> freebsd/current/master
  		}
  	}
  
On branch hardened/current/master
Your branch is up to date with 'origin/hardened/current/master'.

You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Changes to be committed:
	modified:   bin/pwait/pwait.1
	modified:   bin/pwait/tests/pwait_test.sh
	modified:   sys/kern/vfs_default.c
	modified:   sys/kern/vfs_subr.c
	modified:   tests/sys/kern/ptrace_test.c

Unmerged paths:
  (use "git add <file>..." to mark resolution)
	both modified:   bin/pwait/pwait.c

HEAD is now at 324c3861ec69 Merge branch 'freebsd/current/master' into hardened/current/master
==== merge failed and clean up after ====
On branch hardened/current/master
Your branch is up to date with 'origin/hardened/current/master'.

nothing to commit, working tree clean
HEAD is now at 324c3861ec69 Merge branch 'freebsd/current/master' into hardened/current/master
==== END: hardened/current/master ====
